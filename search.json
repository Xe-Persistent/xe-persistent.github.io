[{"title":"2022年7月2日 星期六 晴","url":"/posts/99fec0a61193.html","content":"今天是2022年7月2日，天气：晴☀️，气温26-33℃。\n\n今天白天有幸参加了公司组织的应届生培训的户外拓展项目，体验了三种不同的团队建设小游戏。有以下几点感受：\n\n1. 从开始参加今天的活动到结束，我完成了一种心态的转变。刚踏进园区大门时感觉风光很不错，心情就像是来这里旅游的游客一样愉悦。结果到了集合地点，大家都被安排给了几个教练，然后分成了若干个活动小组，颇有一种「军训」的体验，突然就有了一种莫名的上当受骗的感觉。但在后来的小组活动和游戏环节中，慢慢认识了身边的小伙伴，一起同进退、共奋斗，给我留下了很多深刻的回忆，心态也从一种摆烂的态度转变成了积极向上的态度，感觉不虚此行。\n2. 结合小游戏和现实工作的流程环节，我体会到了团队协作的重要性。有很多小游戏是需要分工、分角色，然后互相搭档配合完成，联系到现实工作中就是团队分工、工作的细分、团队配合等要素。特别是一些需要蒙眼的小游戏，蒙上眼睛的那一刻会有一些恐惧感和无助感，需要饰演其他角色的小伙伴替你获取信息并传达给你，结合现实就是到了一个新的团队或者工作环境，有很多你未知的信息需要从不同角度来获取，接收信息之后完成好自己分内的工作。\n3. 我学会了向其他人展示自己。我属于性格比较内向的人，以前我是很不喜欢做自我介绍的，因为觉得很麻烦，有时会不知道从哪说起。经过这几天一些自我介绍的环节，我逐渐学会了如何向其他小伙伴展示自己积极的一面，更重要的是发现了自身的闪光点，知道自我介绍时该说什么了。当然，在公开场合发言时还是会紧张，这一点可能还需要更长的时间来克服和适应。\n\n尽管我早在今年四月份的时候就提前入职了，但还不敢在许多新人小伙伴面前说自己已经是一名「老油条」，只能说对自己团队成员和已经探索过的业务有所了解。希望这次长达四周的培训能让我更多了解到CET的方方面面吧。在这里祝自己一路顺风！\n\n---\n**非常感谢你的阅读，辛苦了！**\n\n---\n","tags":["日记"],"categories":["杂谈"]},{"title":"如何重构if-else写出优雅高效代码","url":"/posts/14d0abf73d03.html","content":"# 为什么我们写的代码都是if-else？\n程序员想必都经历过这样的场景：刚开始自己写的代码很简洁，逻辑清晰，函数精简，没有一个`if-else`。可随着代码逻辑不断完善和业务的瞬息万变，比如需要对入参进行类型和值进行判断；这里要判断下字段是否为`null`；不同类型执行不同的流程，落地到具体实现只能不停地加`if-else`来处理。渐渐地，代码变得越来越庞大，函数越来越长，代码行数也迅速突破上千行，维护难度也越来越大，到后期基本达到一种难以维护的状态。\n\n**虽然我们都很不情愿写出满屏`if-else`的代码，可逻辑上就是需要特殊判断，很绝望，可也没办法避免啊。**\n\n其实回头看看自己的代码，写`if-else`无外乎两种场景：**异常逻辑处理和不同状态处理。**\n\n两者最主要的区别是：**异常逻辑处理说明只能一个分支是正常流程，而不同状态处理都所有分支都是正常流程。**\n\n## 代码if-else代码太多有什么缺点？\n缺点相当明显了：\n\n1. 最大的问题是代码逻辑复杂，维护性差，极容易引发bug。\n2. 如果使用`if-else`，说明`if`分支和`else`分支的重视是同等的，但大多数情况并非如此，容易引起误解和理解困难。\n\n## 是否有好的方法优化？如何重构？\n方法肯定是有的。重构`if-else`时，心中每时每刻把握一个原则：\n\n**尽可能地维持正常流程代码在最外层。**\n\n意思是说，可以写`if-else`语句时一定要尽量保持主干代码是正常流程，避免嵌套过深。\n\n怎么理解？举两个例子：\n\n> 举例一：异常逻辑处理\n\n```java\nObject obj = getObj();\nif (obj != null) {\n    // do something\n} else {\n    // do something\n}\n```\n\n> 举例二：状态处理\n\n```java\nObject obj = getObj();\nif (obj.getType == 1) {\n    // do something\n} else if (obj.getType == 2) {\n    // do something\n} else {\n    // do something\n}\n```\n\n第一个例子`if (obj != null)`是异常处理，是代码健壮性判断，只有`if`里面才是正常的处理流程，`else`分支是出错处理流程；\n\n而第二个例子不管`type`等于1、2还是其他情况，都属于业务的正常流程。\n\n对于这两种情况，重构的方法也不一样。实现的手段有：*减少嵌套*、*移除临时变量*、*条件取反判断*、*合并条件表达式*等。\n\n下面针对不同情形举几个实例来讲解这些重构方法。\n\n# 异常逻辑处理型重构\n\n## 实例一：合并条件表达式\n重构前：\n\n```java\ndouble disablityAmount() {\n    if (_seniority < 2) {\n        return 0;\n    }\n    if (_monthsDisabled > 12) {\n        return 0;\n    }\n    if (_isPartTime) {\n        return 0;\n    }\n    // do something\n}\n```\n\n重构后：\n\n```java\ndouble disablityAmount() {\n    if (_seniority < 2 || _monthsDisabled > 12 || _isPartTime)\n        return 0;\n    // do something\n}\n```\n\n这里的重构手法叫**合并条件表达式**：如果有一系列条件测试都得到相同结果，将这些结果测试合并为一个条件表达式。\n\n这个重构手法简单易懂，带来的效果也非常明显，能有效地较少`if`语句，减少代码量逻辑上也更加易懂。\n\n## 实例二：移除临时变量\n重构前：\n\n```java\ndouble getPayAmount() {\n    double result;\n    if (_isDead) {\n        result = deadAmount();\n    } else {\n        if (_isSeparated) {\n            result = separatedAmount();\n        } else {\n            if (_isRetired) {\n                result = retiredAmount();\n            } else {\n                result = normalPayAmount();\n            }\n        }\n    }\n    return result;\n}\n```\n\n重构后：\n\n```java\ndouble getPayAmount() {\n    if (_isDead) {\n        return deadAmount();\n    }\n    if (_isSeparated) {\n        return separatedAmount();\n    }\n    if (_isRetired) {\n        return retiredAmount();\n    }\n    return normalPayAmount();\n}\n```\n\n怎么样？比对两个版本，会发现重构后的版本逻辑清晰，简洁易懂。\n\n和重构前到底有什么区别呢？\n\n最大的区别是**减少`if-else`嵌套**。\n\n可以看到，最初的版本`if-else`最深的嵌套有三层，看上去逻辑分支非常多，进到里面基本都要被绕晕。其实，仔细想想嵌套内的`if-else`和最外层并没有关联性，完全可以提取最顶层，改为平行关系，而非包含关系。`if-else`数量没有变化，但是逻辑清晰明了，一目了然。\n\n另一个重构点是**废除了`result`临时变量，直接`return`返回**。好处也显而易见：直接结束流程，缩短异常分支流程。原来的做法先赋值给`result`最后统一`return`，那么对于最后`return`的值到底是哪个函数返回的结果不明确，增加了一层理解难度。\n\n总结重构的要点：**如果`if-else`嵌套没有关联性，直接提取到第一层，一定要避免逻辑嵌套太深。尽量减少临时变量改用`return`直接返回。**\n\n## 实例三：条件取反判断\n重构前：\n\n```java\npublic double getAdjustedCapital() {\n    double result = 0.0;\n    if (_capital > 0.0) {\n        if (_intRate > 0 && _duration > 0) {\n            result = (_income / _duration) * ADJ_FACTOR;\n        }\n    }\n    return result;\n}\n```\n\n第一步，运用第一招：减少嵌套和移除临时变量。\n\n```java\npublic double getAdjustedCapital() {\n    if (_capital <= 0.0) {\n        return 0.0;\n    }\n    if (_intRate > 0 && _duration > 0) {\n        return (_income / _duration) * ADJ_FACTOR;\n    }\n    return 0.0;\n}\n```\n\n这样重构后，还不够，因为主要的语句`(_income / _duration) * ADJ_FACTOR`在`if`内部，并非在最外层，根据优化原则「*尽可能地维持正常流程代码在最外层*」，可以再继续重构。\n\n```java\npublic double getAdjustedCapital() {\n    if (_capital <= 0.0) {\n        return 0.0;\n    }\n    if (_intRate <= 0 || _duration <= 0) {\n        return 0.0;\n    }\n    return (_income / _duration) * ADJ_FACTOR;\n}\n```\n\n这才是好的代码风格，逻辑清晰，一目了然，没有`if-else`嵌套难以理解的流程。\n\n这里用到的重构方法是：**将条件反转使异常情况先退出，让正常流程维持在主干流程**。\n\n## 实例四：减少if-else嵌套\n重构前：\n\n```java\n// 查找年龄大于18岁且为男性的学生列表 \npublic ArrayList<Student> getStudents(int uid) {\n    ArrayList<Student> result = new ArrayList<Student>();\n    Student stu = getStudentByUid(uid);\n    if (stu != null) {\n        Teacher teacher = stu.getTeacher();\n        if (teacher != null) {\n            ArrayList<Student> students = teacher.getStudents();\n            if (students != null) {\n                for (Student student : students) {\n                    if (student.getAge() > = 18 && student.getGender() == MALE) {\n                        result.add(student);\n                    }\n                }\n            } else {\n                logger.error(\"获取学生列表失败\");\n            }\n        } else {\n            logger.error(\"获取老师信息失败\");\n        }\n    } else {\n        logger.error(\"获取学生信息失败\");\n    }\n    return result;\n}\n```\n\n典型的「箭头型」代码，最大的问题是**嵌套过深**，解决方法是异常条件先退出，保持主干流程是核心流程。\n\n重构后：\n\n```java\n// 查找年龄大于18岁且为男性的学生列表\npublic ArrayList<Student> getStudents(int uid) {\n    ArrayList<Student> result = new ArrayList<Student>();\n    Student stu = getStudentByUid(uid);\n    if (stu == null) {\n        logger.error(\"获取学生信息失败\");\n        return result;\n    }\n    Teacher teacher = stu.getTeacher();\n    if (teacher == null) {\n        logger.error(\"获取老师信息失败\");\n        return result;\n    }\n    ArrayList<Student> students = teacher.getStudents();\n    if (students == null) {\n        logger.error(\"获取学生列表失败\");\n        return result;\n    }\n    for (Student student : students) {\n        if (student.getAge() > 18 && student.getGender() == MALE) {\n            result.add(student);\n        }\n    }\n    return result;\n}\n```\n\n# 状态处理型重构\n\n## 实例一：封装成内部函数\n重构前：\n\n```java\ndouble getPayAmount() {\n    Object obj = getObj();\n    double money = 0;\n    if (obj.getType == 1) {\n        ObjectA objA = obj.getObjectA();\n        money = objA.getMoney() * obj.getNormalMoneryA();\n    } else if (obj.getType == 2) {\n        ObjectB objB = obj.getObjectB();\n        money = objB.getMoney() * obj.getNormalMoneryB() + 1000;\n    }\n}\n```\n\n重构后：\n\n```java\ndouble getPayAmount() {\n    Object obj = getObj();\n    if (obj.getType == 1) {\n        return getType1Money(obj);\n    } else if (obj.getType == 2) {\n        return getType2Money(obj);\n    }\n}\n\ndouble getType1Money(Object obj) {\n    ObjectA objA = obj.getObjectA();\n    return objA.getMoney() * obj.getNormalMoneryA();\n}\n\ndouble getType2Money(Object obj) {\n    ObjectB objB = obj.getObjectB();\n    return objB.getMoney() * obj.getNormalMoneryB() + 1000;\n}\n```\n\n这里使用的重构方法是：**把`if-else`内的代码都封装成一个内部函数**。内部函数的好处是屏蔽内部实现，缩短`if-else`分支的代码。代码结构和逻辑上清晰，能一下看出来每一个条件下实现的功能。\n\n## 实例二：用多态取代条件表达式\n针对状态处理的代码，一种优雅的做法是「*《重构》推荐做法*」**用多态取代条件表达式**。\n\n> 你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。将这个表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。\n\n重构前：\n\n```java\ndouble getSpeed() {\n    switch (_type) {\n        case EUROPEAN:\n            return getBaseSpeed();\n        case AFRICAN:\n            return getBaseSpeed() - getLoadFactor() * _numberOfCoconuts;\n        case NORWEGIAN_BLUE:\n            return (_isNailed) ? 0 : getBaseSpeed(_voltage);\n    }\n}\n```\n\n重构后：\n\n```java\nclass Bird {\n    abstract double getSpeed();\n}\n\nclass European extends Bird {\n    double getSpeed() {\n        return getBaseSpeed();\n    }\n}\n\nclass African extends Bird {\n    double getSpeed() {\n        return getBaseSpeed() - getLoadFactor() * _numberOfCoconuts;\n    }\n}\n\nclass NorwegianBlue extends Bird {\n    double getSpeed() {\n        return (_isNailed) ? 0 : getBaseSpeed(_voltage);\n    }\n}\n```\n\n可以看到，使用多态后直接没有了`if-else`，但使用多态对原本代码修改过大，需要下一番功夫才行。最好在设计之初就使用多态方式。\n\n# 小结\n`if-else`代码是每一个程序员最容易写出的代码，同时也是最容易被写烂的代码，稍不注意，就产生一堆难以维护和逻辑混乱的代码。\n\n针对条件型代码重构时刻把握一个原则：\n\n**尽可能地维持正常流程代码在最外层，保持主干流程是正常核心流程。**\n\n为维持这个原则，合并条件表达式可以有效地减少`if`语句数目，减少嵌套能减少深层次逻辑，异常条件先退出自然而然主干流程就是正常流程。\n\n针对状态处理型重构方法有两种：一种是把不同状态的操作封装成内部函数，简短`if-else`内代码行数；另一种是利用面向对象多态特性直接干掉了条件判断。\n\n现在回头看看自己的代码，犯了哪些典型错误，赶紧运用这些重构方法重构代码吧！\n\n---\n**非常感谢你的阅读，辛苦了！**\n\n---\n本文转自CSDN博主「yinnnnnnn」的文章[6个实例详解如何把if-else代码重构成高质量代码](https://blog.csdn.net/qq_35440678/article/details/77939999)\n","tags":["后端","Java","重构"],"categories":["经验分享"]},{"title":"git rebase VS git merge？更优雅的Git合并方式值得拥有","url":"/posts/21df300fabde.html","content":"# 写在前面\n你在使用Git合并分支时只会使用`git merge`吗？有时使用`git rebase`可以比`git merge`做出更优雅的操作。\n\n![合并与变基](https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/hero.svg)\n\n另外，如果你不能很好的应用Git，那么这里为你提供一个非常棒的Git在线练习工具：[Git Online](https://learngitbranching.js.org)，你可以更直观的看到你所使用的命令会产生什么效果。\n\n# Merge与Rebase\n不知怎么，`git rebase`命令被赋予了一个神奇的污毒声誉，初学者应该远离它，但它实际上可以让开发团队在使用时更加轻松。\n\n> 你可以将它理解成「七伤拳」，「七伤拳」并不是不能练，只是练「七伤拳」有一个先诀条件，那就是内功境界一定要非常高，即你要充分理解`git rebase`命令。\n\n在本文中，我们将`git rebase`与`git merge`命令进行比较。在Git工作流中，说明所有可以使用Rebase的场景。\n\n# 概念概述\n关于`git rebase`，首先要理解的是它解决了和`git merge`同样的问题。这两个命令都旨在将更改从一个分支合并到另一个分支，但二者的合并方式却有很大的不同。\n\n当你在专用分支上开发新feature时，另一个团队成员在`master`分支提交了新的commits，这会发生什么？这会导致分叉的历史记录。对于这个问题，使用Git作为协作工具的任何人来说都应该很熟悉。\n\n![分叉的提交历史记录](https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/01.svg)\n\n现在，假设在`master`分支上的新提交与你正在开发的feature相关。需要将新提交合并到你的`feature`分支中，你可以有两个选择：merge或者rebase。\n\n## Merge方式\n最简单的方式是通过以下命令将`master`分支合并到`feature`分支中：\n\n```powershell\ngit checkout feature\ngit merge master\n```\n\n或者，你可以将其浓缩为一行命令：\n\n```powershell\ngit merge feature master\n```\n\n这会在`feature`分支中创建一个新的**merge commit**，它将两个分支的历史联系在一起，请看如下所示的分支结构：\n\n![将master分支合并到feature分支中](https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/02.svg)\n\n使用merge是很好的方式，因为它是一种**非破坏性**的操作。现有分支不会以任何方式被更改，这避免了rebase操作所产生的潜在缺陷（下面讨论）。\n\n另一方面，这也意味着`feature`分支每次需要合并上游更改时，它都将产生一个额外的合并提交。如果`master`提交非常活跃，这可能会严重污染你的`feature`分支历史记录。尽管可以使用高级选项`git log`缓解此问题，但它可能使其他开发人员**难以理解项目的历史记录**。\n\n## Rebase方式\n作为merge的替代方法，你可以使用以下命令将`master`分支合并到`feature`分支上：\n\n```powershell\ngit checkout feature\ngit rebase master\n```\n\n这会将整个`feature`分支移动到`master`分支的顶端，从而有效地整合了所有`master`分支上的提交。但是，与merge提交方式不同，rebase通过为原始分支中的每个提交创建全新的commits来**重写**项目历史记录。\n\n![将feature分支rebase到master分支上](https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/03.svg)\n\nrebase的主要好处是可以获得更清晰的项目历史。首先，它消除了`git merge`所需的不必要的合并提交；其次，正如你在上图中所看到的，rebase会产生完美线性的项目历史记录，你可以在`feature`分支上没有任何分叉的情况下一直追寻到项目的初始提交。这样可以通过命令`git log`，`git bisect`和`gitk`更容易地导航查看项目。\n\n但是，针对这样的提交历史我们需要权衡其「安全性」和「可追溯性」。如果你不遵循**Rebase的黄金法则**，重写项目历史记录可能会对你的协作工作流程造成灾难性后果。而且，rebase会丢失合并提交的上下文，你也就无法看到上游更改是何时合并到feature中的。\n\n## 交互式Rebase\n交互式rebase使你有机会在将commits移动到新分支时更改这些commits。这比自动rebase更强大，因为它提供了对分支提交历史的完全控制。通常，这用于在合并`feature`分支到 `master`之前清理其杂乱的历史记录。\n\n要使用交互式rebase，需要使用`git rebase`和`-i`选项：\n\n```powershell\ngit checkout feature\ngit rebase -i master\n```\n\n这将打开一个文本编辑器，列出即将移动的所有提交：\n\n```powershell\npick 33d5b7a Message for commit #1\npick 9480b3d Message for commit #2\npick 5c67e61 Message for commit #3\n```\n\n此列表准确定义了执行rebase后分支的外观。通过更改`pick`命令或重新排序条目，你可以使分支的历史记录看起来像你想要的任何内容。例如，如果第二次提交fix了第一次提交中的一个小问题，您可以使用以下`fixup`命令将它们浓缩为一个提交：\n\n```powershell\npick 33d5b7a Message for commit #1\nfixup 9480b3d Message for commit #2\npick 5c67e61 Message for commit #3\n```\n\n保存并关闭文件时，Git将根据您的指示执行rebase，从而产生如下所示的项目历史记录：\n\n![使用交互式rebase来压缩提交](https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/04.svg)\n\n消除这种无意义的提交使你的功能历史更容易理解。这是`git merge`根本无法做到的事情。至于commits条目前的`pick`、`fixup`、`squash`等命令，在Git目录执行`git rebase -i`即可查看到，大家按需重排或合并提交即可，注释说明非常清晰，在此不做过多说明。\n\n# Rebase的黄金法则\n一旦你理解了什么是rebase，最重要的是要学习什么时候不能使用它。`git rebase`的黄金法则是永远不要在公共分支上使用它。\n\n例如，想想如果你rebase`master`分支到`feature`分支之上会发生什么：\n\n![Rebase到主分支](https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/05.svg)\n\nrebase将所有`master`分支上的提交移动 feature 分支的顶端。问题是这只发生在**你自己**的存储库中。所有其他开发人员仍在使用原始版本的`master`。由于rebase产生了全新 commit，Git会认为你的`master`分支历史与其他人的历史不同。\n\n此时，同步两个`master`分支的唯一方法是将它们合并在一起，但是这样会产生额外的合并提交和两组包含相同更改的提交（原始提交和通过rebase更改的分支提交）。不用说，这是一个令人非常困惑的情况。\n\n因此，在你运行`git rebase`命令之前，总是问自己，**还有其他人在用这个分支吗？** 如果答案是肯定的，那就把你的手从键盘上移开，开始考虑采用非破坏性的方式进行改变（例如`git revert`命令）。否则，你可以随心所欲地重写历史记录。\n\n## Force Push\n如果你尝试将rebase了的`master`分支推送回remote repository，Git将阻止你这样做，因为它会与远程`master`分支冲突。但是，你可以通过传递`--force`标志来强制推送，如下所示：\n\n```powershell\n# Be very careful with this command!\ngit push --force\n```\n\n这样你自己repository的内容将覆盖远程`master`分支的内容，但这会使团队的其他成员感到困惑。因此，只有在确切知道自己在做什么时才要非常小心地使用此命令。\n\n如果没有人在feature分支上作出更改，你可以使用force push将本地内容推送到remote repository做清理工作。\n\n# 工作流程演练\nrebase可以根据你所在团队的需要方便的整合到现有的Git工作流程中。在本节中，我们将了解rebase在功能开发的各个阶段可以提供的好处。\n\n在任何工作流程中，利用`git rebase`是为每个功能创建专用分支。这为你提供了必要的分支，以安全地利用rebase：\n\n![在专用分支中开发功能](https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/06.svg)\n\n## 本地清理\n将rebase纳入工作流程的最佳方法之一是清理本地正在进行的功能。通过定期执行交互式rebase，你可以确保功能中的每个提交都具有针对性和意义。这可以使你在编写代码时无需担心将其分解为隔离的提交（多个提交），你可以在事后修复整合它。\n\n使用`git rebase`时，有两种情况：`feature`父分支（例如`master`）的提交，或在`feature`中的早期提交。我们在**交互式 Rebase**部分已经介绍了第一种情况的示例。我们来看后一种情况，当你只需要修复最后几次提交时，以下命令仅做最后`3`次提交的交互式rebase。\n\n```powershell\ngit checkout feature\ngit rebase -i HEAD~3\n```\n\n通过指定`HEAD~3`，你实际上并没有移动分支，你只是交互式地重写其后的`3`个提交。请注意，这**不会**将上游更改合并到`feature`分支中。\n\n![Rebase到HEAD~3](https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/07.svg)\n\n如果要使用此方法重写整个功能，`git merge-base`命令可用于查找`feature`分支的原始base。以下内容返回原始base的提交ID，然后你可以将其传递给`git rebase`：\n\n```powershell\ngit merge-base feature master\n```\n\n交互式rebase的使用是引入`git rebase`工作流的好方法，因为它只影响本地分支。其他开发人员唯一能看到的就是你提交的最终版，这应该是一个简洁易懂易跟踪的分支历史记录。\n\n但同样，这仅适用于私有`feature`分支。如果你通过相同的功能分支(公共分支)与其他开发人员协作，那么你是**不被允许**重写其历史记录的。\n\n## 将上游更改合并到功能分支中\n在**概念概述**部分中，我们了解了`feature`分支可以使用`git merge`或`git rebase`合并`master`分支的上游更改。merge是一个安全的方式，可以保留git repository的整个历史记录，而rebase则是通过将`feature`分支移动到`master`顶端来创建线性历史记录。\n\n这种使用`git rebase`类似于本地清理，但在此过程中它包含了那些来自master上游的提交。\n\n请记住，将当前提交rebase到远程branch（非master分支）一样是合法的。当与另一个开发人员协作使用相同的功能并且你需要将他们的更改合并到你的repository时，就会发生这种情况。\n\n例如，如果你和另一个名为John的开发人员添加了对`feature`分支的提交，在你fetch（注意fetch并不会自动merge）来自John的远程`feature`分支后，你的repository可能如下所示：\n\n![在同一个feature分支上进行协作](https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/08.svg)\n\n你可以合并来自上游的分叉：要么用`john/feature`**merge**本地`feature`，要么**rebase**本地`feature`到`john/feature`的顶部。\n\n![合并与变基到远程分支](https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/09.svg)\n\n请注意，此rebase不违反**Rebase 黄金规则**，因为只有你的本地`feature`提交被移动，之前的所有内容都不会受到影响。这就像是说「将我的更改添加到John已经完成的工作中」。在大多数情况下，这比通过合并提交与远程分支同步更直观。\n\n默认情况下，使用`git pull`命令执行合并，但你可以通过向其传递`--rebase`选项来强制它将远程分支以rebase方式集成。\n\n```powershell\ngit pull --rebase\n```\n\n## 使用Pull请求Review Feature\n如果你在代码审查过程中使用pull请求，在使用了pull请求之后你应该避免使用`git rebase`。一旦你发出pull请求，其他开发人员就会查看你的提交，这意味着它是一个**公共**分支。重写其历史记录将使Git和你的队友无法跟踪添加到该功能的任何后续提交。\n\n其他开发人员的任何更改都需要合并`git merge`而不是`git rebase`。\n\n因此，在提交拉取请求之前，通常使用交互式rebase清理代码是个好的办法。注意使用顺序。\n\n## 集成已批准的功能\n在你的团队批准某项feature后，你可以选择将该功能rebase到`master`分支的顶端，然后`git merge`再将该功能集成到主代码库中。\n\n这与将上游更改合并到feature分支中的情况类似，但由于你不允许在`master`分支中重写提交，因此你必须最终使用`git merge`该功能进行集成。但是，通过在merge之前执行rebase，你可以确保会以`fast-forward`方式merge，从而产生完美的线性历史记录。\n\n> `fast-forward`指的是merge之后不会出现新的commit对象，分支的合并线是一条直线，被合并的分支，没有分叉，会丢失，再看不到该分支历史。相对地，`no-fast-forward`方式merge之后会出现一个merge commit对象，分支的合并线在主干外出现一条分叉，在merge节点处合并为主干。\n\n![使用和不使用rebase将feature集成到master中](https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/10.svg)\n\n如果您不熟悉`git rebase`，可以随时在临时分支中执行rebase。这样，如果你不小心弄乱了功能的历史记录，可以查看原始分支，然后重试。例如：\n\n```powershell\ngit checkout feature\ngit checkout -b temporary-branch\ngit rebase -i master\n# [Clean up the history]\ngit checkout master\ngit merge temporary-branch\n```\n\n# 总结\n如果你更喜欢没有不必要的干净的合并提交，线性历史记录，你就需要开始了解使用rebase功能。同时你应该使用`git rebase`而不是`git merge`集成来自另一个分支的更改。\n\n另一方面，如果你想保留项目的完整历史记录并避免重写公共提交的风险，你可以坚持使用`git merge`。这两种选择都是完全有效的，但至少现在你可以选择利用`git rebase`的好处 。\n\n\n---\n**非常感谢你的阅读，辛苦了！**\n\n---\n本文转自公众号「日拱一兵」的文章[git rebase VS git merge？更优雅的git合并方式值得拥有](https://www.cnblogs.com/FraserYu/p/11192840.html)\n","tags":["Git"],"categories":["经验分享"]},{"title":"如何使用Git管理hexo博客项目仓库","url":"/posts/8d70d0c84034.html","content":"# 前言\n在日常写博客的时候，我一般会在多台电脑上写作，然后在本地生成静态页面，部署到`GitHub Page`；此外，博客的源代码也需要在多台电脑之间同步，保证在部署页面时的一致性。因此，管理好博客的远程仓库是非常有必要的。今天就和大家分享一下，我平时是如何管理hexo博客项目仓库的。\n\n# 管理分支\nhexo博客项目的使用环境为个人项目，因此无需过多关注多人协作情况下`Git`的注意事项。我们完全可以自己定义一套规矩，在写作时遵守即可。\n\n`hexo deploy`命令会强行覆盖远程仓库的静态页面文件，因此有必要将页面文件与源代码分开存储。可以另外创建一个仓库，也可以新建一个分支，两个分支存储不同的文件。我使用的方案是新建一个分支。\n\n## 使用不同分支\n在博客的根目录下找到`_config.yml`文件，修改`deploy`配置如下：\n\n```yml\ndeploy:\n    type: git\n    repository: // 填写你的仓库地址\n    branch: master\n```\n\n这时，`hexo deploy`命令会将站点文件推送至默认的`master`分支。我们可以在`GitHub`中新建一个`hexo`分支，在本地也新建一个`hexo`分支，然后切换至`hexo`分支，将源代码`push`到远程的`origin/hexo`上，并将其设置为默认分支。这样的好处是每次执行`git clone`命令时无需关注克隆的是哪一个分支，因为默认克隆的是源代码而不是站点文件。之后，每次执行`hexo deploy`，都会创建一个提交信息为部署时间的commit，并刷新页面。\n\n于是，`hexo`分支的提交历史反映了我们对博客的页面做出的改动，`master`分支的提交历史反映了页面的更新历史。\n\n## 合并修改\n当我在一台电脑上写作或修改源代码并推送至远程仓库后，如果要在另一台电脑上继续作业，正确的做法是先执行`git fetch`命令拉取远程仓库的代码，再执行`git pull`命令同步之前做的修改，保证一致性后再完成工作。如果我不小心忘记这一次同步呢？直接在本地继续工作，然后提交。如果修改的不是前一台电脑更改的文件，那倒不会产生什么影响，只需要补做前面同步的操作即可。如果恰好修改了前一台电脑更改的文件，那么显然会产生冲突。\n\n在多人协助的项目中，冲突也是时有发生，我们一般会采用执行`git merge`命令然后手动解决冲突的方式，这样会在分支上产生一个分叉，然后合并，同时产生一条`merge`信息提示这里曾进行过合并，`Git`会完整记录下我们对分支进行的每一次提交。\n\n然而，对于个人项目，我不希望我的分支产生多余的分叉，我想要让历史提交记录保持一条干净的直线，这时可以使用`git rebase`命令代替`git merge`，将本地的修改放到远程仓库上次修改的后面，使博客的更新历史既符合时间线又不产生分叉。\n\n# 管理提交信息\n上面提到，分支上的每一次提交就是博客更新的时间线。除了保证分支的提交历史清晰可辨，提交的信息也要做到言简意赅。一般来说，提交信息要写明这次提交修改了哪些内容，并尽可能地简洁，这样在浏览分支的提交历史时，能清楚地明白每次提交做了什么事情。\n\n## 使用amend\n当我在本地做了一些修改后进行了一次commit，之后又做了一些修改，想将这两次的修改合并到一个commit中，这时可以使用`--amend`参数，加到`git commit`后面，同时还能修改上一次提交时的提交信息。\n\n如果已经将上一次修改push到了远程仓库，我们也能使用`git commit --amend`命令，但执行`git push`命令时，需要加上`--force`参数强制推送到远程仓库\n\n使用`WebStorm`时，只需在commit界面勾选`amend`复选框即可。如果需要强制推送，在push时展开按钮选择`force push`即可。\n\n## 使用rebase\n如果需要修改前几次的提交信息，可以使用`git rebase -i`命令，具体使用方法如下：\n\n```powershell\ngit rebase -i HEAD~2 // 2 表示最近两条commit\ngit rebase -i {commitID} // 例如 git rebase -i d95ddfb\ngit rebase -i --root // 表示从第一条commit开始编辑\n```\n> 指定`HEAD~`后面的数字表示编辑最近若干条commit  \n> 指定`commit ID`表示编辑这条commit之前的记录  \n> 指定--root参数表示从第一条commit开始编辑\n\n执行rebase命令后，会出现rebase的编辑窗口，窗口底下会有提示怎么操作。\n\n这里有几种修改选项：\n\n- `pick`：保留该commit\n- `reword`：保留该commit，但我需要修改该commit的Message\n- `edit`：保留该commit，但我要停下来修改该提交(包括修改文件)\n- `squash`：将该commit和前一个commit合并\n- `fixup`：将该commit和前一个commit合并，但我不要保留该提交的注释信息\n- `exec`：执行shell命令\n- `drop`：丢弃这个commit\n\n按字母`O`键进入编辑状态，开始修改内容。\n\n按`Esc`键退出编辑状态，可以输入各种命令，最常用的是输入`:q`直接退出，输入`:wq`进行保存并退出。\n\n修改完成后，执行`git push --force`命令推送至远程仓库即可。\n\n## UI交互式rebase\n上面使用命令行窗口编辑提交信息的操作非常繁琐，如果使用`WebStorm`来操作会非常简单。只需打开`Git`标签页，在中间的分支上选择你要编辑的起始commit，右键选择`Interactively Rebase From Here`，然后在弹出的窗口中编辑每一条要修改的commit即可。\n\n## 重置代码\n如果遇到严重的问题，想要强制拉取并覆盖本地代码，可以使用`git reset`将本地分支重置到远程分支的最新提交。\n\n```powershell\ngit fetch --all\ngit reset --hard origin/hexo\n```\n\n# 使用Gitmoji\n此外，我们还可以在每条提交信息前插入一些约定好的`emoji`表情，使得commit信息更加生动形象。因为是使用在`Git`里的，所以被称为`Gitmoji`。我节选了一些内容，更多用法可以参考它的[官网](https://gitmoji.dev/)。\n\n| emoji | emoji代码                | 说明              |\n|-------|------------------------|-----------------|\n| 🎨    | :art:                  | 改进代码结构/代码格式     |\n| ⚡️    | :zap:                  | 提升性能            |\n| 🔥    | :fire:                 | 移除代码或文件         |\n| 🐛    | :bug:                  | 修复bug           |\n| ⏪     | :rewind:               | 回退修改            |\n| 📦    | :package:              | 上传已经完成编译或者打包的项目 |\n| 👽    | :alien:                | API发生改变         |\n| 🚚    | :truck:                | 移动或者重命名文件       |\n| 📄    | :page_facing_up:       | 添加或者升级证书        |\n| 💥    | :boom:                 | 有结构性破坏的修改       |\n| 🍱    | :bento:                | 添加资源            |\n| 🔍    | :mag:                  | 改进搜索方式          |\n| 🥅    | :goal_net:             | 发现错误            |\n| 💫    | :dizzy:                | 添加了动画           |\n| 🗑    | :wastebasket:          | 过期代码需要被清理       |\n| 🚑    | :ambulance:            | 关键补丁            |\n| ✨     | :sparkles:             | 引入新的功能          |\n| 📝    | :memo:                 | 写README文档       |\n| 🚀    | :rocket:               | 部署功能            |\n| 💄    | :lipstick:             | 更新UI和样式文件       |\n| 🎉    | :tada:                 | 初次提交            |\n| 🔖    | :bookmark:             | 发行/版本标签         |\n| ⬆️    | :arrow_up:             | 升级依赖            |\n| ⬇️    | :arrow_down:           | 降级依赖            |\n| ➕     | :heavy_plus_sign:      | 添加依赖            |\n| ➖     | :heavy_minus_sign:     | 删除依赖            |\n| 🔨    | :hammer:               | 重构              |\n| 🐳    | :whale:                | Docker 相关工作     |\n| 🔧    | :wrench:               | 修改配置文件          |\n| 🌐    | :globe_with_meridians: | 国际化与本地化         |\n| ✏️    | :pencil2:              | 修复typo          |\n\n# 小结\n- 博客项目使用两个分支分别存储源代码和站点文件，两个分支的提交历史分别反映了博客的页面改动与页面的更新历史；\n- 使用`Git`命令可以合并commit、修改commit信息。使用`WebStorm`操作更加方便；\n- 使用`Gitmoji`可以生动形象地描述commit内容。\n\n---\n**非常感谢你的阅读，辛苦了！**\n\n---\n参考文章： (感谢以下资料提供的帮助)\n- [Rebase - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648)\n- [git rebase详解](https://blog.csdn.net/weixin_42310154/article/details/119004977)\n- [Git 如何修改历史 Commit message](https://zhuanlan.zhihu.com/p/401811121)\n- [Git修改commit信息方法大全](https://blog.csdn.net/weixin_43314519/article/details/123317135)\n","tags":["Git","博客"],"categories":["经验分享"]},{"title":"初识MyBatis-Plus","url":"/posts/6a03ebbdc425.html","content":"# 前言\n在前面的Java学习笔记中，我提到过两次`MyBatis-Plus`，可能大家已经对这个名词有些耳熟。我对它的定义是：一个方便的操作数据库功能的工具包。\n\n在它的官方文档上写道：`MyBatis-Plus`是一个`MyBatis`的增强工具，在`MyBatis`的基础上**只做增强不做改变**，为简化开发、提高效率而生。`MyBatis`与`MyBatis-Plus`都是`ORM`框架（*对象-关系映射框架*），对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为**对象**，在数据库中表现为**关系数据**。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射框架(`ORM`)一般以中间件的形式存在，主要实现对象到关系数据库数据的映射。\n\n当我们编写一个应用程序时，我们可能会写特别多数据访问层的代码，从数据库添加、删除、读取对象信息，而这些代码都是重复的，如果使用`ORM`则会大大减少重复性代码。在使用`MyBatis-Plus`的时候，我总是为之惊叹：原来数据库操作能这么简单！于是我写下这篇文章记录它的一些使用方法。\n\n# 应用\n将`MyBatis-Plus`引入`Spring`项目非常容易，网上有许多实例，在此不做讲解。接下来，我主要介绍如何使用`MyBatis-Plus`的条件构造器编写业务逻辑。大体上，`MyBatis-Plus`从数据库表到前端接口的业务流程是`数据库表->DTO->Mapper->Service->Controller`，因此，我将顺着这条流程依次讲解每个环节要使用`MyBatis-Plus`编写哪些代码。\n\n## 数据库表\n我以一个存储测量设备的数据库表为例，编写与它相关的增删改查接口。下面是它的表结构：\n> MonitoringDevice\n\n| 字段         | 数据类型    | 注释   |\n|------------|---------|------|\n| id         | bigint  | 设备id |\n| name       | varchar | 设备名  |\n| model      | varchar | 设备型号 |\n| type       | varchar | 设备类型 |\n| illustrate | varchar | 说明   |\n| location   | varchar | 设备位置 |\n| accuracy   | varchar | 测量精度 |\n| frequency  | varchar | 校正频率 |\n\n此外，还有一些与该表存在关联的其他数据表，主要通过**外键**与其关联，在此不做举例。\n\n## DTO\n`DTO`即数据传输对象，是数据从后端传输到前端的载体。大体上，一个`DTO`要包含一个数据库表的部分或所有字段信息。为了减少重复代码，我将这些表的重复字段单列出一个`ModelDTO`，让其他的`DTO`继承这个`ModelDTO`。建议使用`Lombok`插件提供的`@Data`注解，可以为`DTO`的私有成员自动生成`getter`和`setter`方法。\n\n> ModelDTO.java\n```java\n@Data\npublic class ModelDTO {\n\n    private String name;\n\n    private Long id;\n}\n```\n\n> MonitoringDeviceDTO.java\n```java\n@EqualsAndHashCode(callSuper = true)\n@TableName(\"monitoringdevice\")\n@Data\npublic class MonitoringDeviceDTO extends ModelDTO {\n    private String model;\n\n    private String type;\n\n    private String illustrate;\n\n    private String location;\n\n    private String accuracy;\n\n    private String frequency;\n}\n```\n\n## Mapper\n`Mapper`的编写非常简单，只需继承`BaseMapper`即可，以`MonitoringDeviceMapper`为例：\n\n> MonitoringDeviceMapper.java\n```java\n@Mapper\npublic class MonitoringDeviceMapper extends BaseMapper<MonitoringDeviceDTO> {\n\n}\n```\n\n## Service\n事实上，这些`Mapper`继承`BaseMapper`后已经为我们提供了默认的`CRUD`接口和一些默认方法。当这些接口和方法不满足我们需要的功能时，就需要自行编写`Service`。\n> `CRUD`是指做计算处理时的增加(`Create`)、读取查询(`Retrieve`)、更新(`Update`)和删除(`Delete`)几个单词的首字母简写。代表了数据库或持久层的基本操作功能。\n\n定义`Service`类时，在私有变量`Mapper`前加上`@Autowired`注解。\n\n> MonitoringDeviceService.java\n```java\n@Service\npublic class MonitoringDeviceService {\n    @Autowired\n    private MonitoringDeviceMapper monitoringDeviceMapper;\n}\n```\n\n### 增加和编辑数据\n首先是增加和编辑数据的逻辑。这里为了便于维护代码，我定义了`RequestBody`作为两个方法的入参。\n\n在增加方法中，我添加了判断入参字段是否合法的逻辑，然后调用`insert()`方法插入一行数据。\n\n由于`DTO`与`RequestBody`都是`JavaBean`，可以使用`BeanUtils`的`copyProperties()`方法将`RequestBody`的参数复制给`DTO`。\n\n```java\npublic Boolean addDevice(AddMonitoringDeviceReq device) {\n    if (!DetermineEnum.isInclude(device.getType())) {\n        throw new ParamException(\"参数不支持\");\n    }\n    MonitoringDeviceDTO instance = new MonitoringDeviceDTO();\n    BeanUtils.copyProperties(device, instance);\n    monitoringDeviceMapper.insert(instance);\n    return true;\n}\n```\n\n在编辑方法中，使用链式条件构造器`LambdaQueryChainWrapper`根据传入的实体`id`查询`Device`表中是否有对应的数据，`eq()`定义了一个相等条件进行查询，再使用`exists()`方法返回布尔值，以判断查询到的数据是否存在，最后调用`insert()`方法即可。\n> 注意：`insert()`会自动根据数据是否存在，即插入的是否为重复行，若不存在则新增一条数据，若存在则编辑该条数据。\n\n```java\npublic MonitoringDeviceDTO editDevice(EditMonitoringDeviceReq device) {\n    boolean exists = new LambdaQueryChainWrapper<>(monitoringDeviceMapper)\n            .eq(MonitoringDeviceDTO::getId, device.getId()).exists();\n    if (!exists) {\n        throw new NotFoundException(\"设备不存在\");\n    }\n    MonitoringDeviceDTO instance = new MonitoringDeviceDTO();\n    BeanUtils.copyProperties(device, instance);\n    return monitoringDeviceMapper.insert(instance);\n}\n```\n\n### 查询数据\n然后是查询数据的逻辑。首先是最简单的根据`id`获取数据，只需调用`selectById()`默认方法即可。\n\n```java\npublic MonitoringDeviceDTO getDeviceById(Long deviceId) {\n    if (Objects.isNull(deviceId)) {\n        return null;\n    }\n    return monitoringDeviceMapper.selectById(deviceId);\n}\n```\n之后是根据`Determine`表的字段查询数据。由于`Determine`表是通过外键`deviceId`与该表的`id`进行关联的，要查询`Device`表的数据，首先要获得`Determine`表的`deviceId`字段，按照这个逻辑编写条件构造器即可，使用`one()`返回一行数据，之后调用前面的`getDeviceById()`方法，传入获得的`deviceId`。\n\n```java\npublic MonitoringDeviceDTO getDeviceByParamId(Long paramId) {\n    if (Objects.isNull(paramId)) {\n        return null;\n    }\n    return getDeviceById(new LambdaQueryChainWrapper<>(determineMapper)\n            .eq(DetermineDTO::getCalcParamId, paramId)\n            .one().getDeviceId());\n}\n```\n\n然后是根据设备类型批量获取数据，同样使用`eq()`定义相等查询条件，使用`list()`返回多行数据，以`list`数组的形式作为返回值。\n\n```java\npublic List<MonitoringDeviceDTO> getDeviceByType(String type) {\n    if (!DetermineEnum.isInclude(type)) {\n        throw new ParamException(\"类型不支持\");\n    }\n    return new LambdaQueryChainWrapper<>(monitoringDeviceMapper)\n            .eq(MonitoringDeviceDTO::getType, type).list();\n}\n```\n\n最后是一个相对复杂的多表联合查询的方法。根据`Source`表的`id`获取与之关联的若干个`CalcParam`，再依次获取这些`CalcParam`的id，存入`paramIdList`，然后在`Determine`表中查询`ObtainingMethod`字段为2、且`CalcParamId`与刚才`paramIdList`匹配的数据行，最后根据这些`Determine`获取设备。\n\n在上面这串逻辑中，除了前面提到的`eq()`相等条件外，还使用到了`in()`匹配字段条件，并在其中穿插使用`Stream`处理和转换数据，是一次`MyBatis-Plus`与`Stream`的综合运用。\n\n```java\npublic List<MonitoringDeviceDTO> getDeviceBySource(Long sourceId) {\n    boolean exists = new LambdaQueryChainWrapper<>(emissionSourceMapper)\n            .eq(EmissionSourceDTO::getId, sourceId).exists();\n    if (!exists) {\n        throw new NotFoundException(\"数据不存在\");\n    }\n    List<EmissionCalcParamDTO> emissionCalcParams = emissionSourceCalcParamMapper\n            .selectList(new QueryWrapper<>(EmissionCalcParamDTO.class)\n                    .treeNode(ModelLabelConstant.EMISSION_SOURCE, sourceId));\n    if (CollectionUtils.isEmpty(emissionCalcParams)) {\n        throw new DefaultCarbonException(\"参数异常\");\n    }\n    List<Long> paramIdList = emissionCalcParams.stream()\n            .map(EmissionCalcParamDTO::getId)\n            .collect(Collectors.toList());\n    List<DetermineDTO> determineList = new LambdaQueryChainWrapper<>(determineMapper)\n            .eq(DetermineDTO::getObtainingMethod, 2)\n            .in(DetermineDTO::getCalcParamId, paramIdList)\n            .list();\n    return determineList.stream()\n            .map(DetermineDTO::getDeviceId)\n            .map(this::getDeviceById)\n            .collect(Collectors.toList());\n}\n```\n\n### 删除数据\n最后是删除数据的逻辑，删除`Device`表的数据同时要删除与其关联的`MaintenanceRecord`表数据，先根据id查询`MaintenanceRecord`表中拥有与之相同的`deviceId`外键的数据，再转换成`id`，使用`deleteBatchIds()`方法批量删除即可，最后调用`deleteById()`方法删除设备。\n\n```java\npublic Boolean deleteDevice(Long deviceId) {\n    List<MaintenanceRecordDTO> records = maintenanceRecordService.getRecordByDeviceId(deviceId);\n    if (CollectionUtils.isNotEmpty(records)) {\n        monitoringDeviceMapper.deleteBatchIds(records.stream()\n                .map(MaintenanceRecordDTO::getId)\n                .collect(Collectors.toList()));\n    }\n    return monitoringDeviceMapper.deleteById(deviceId) == 1;\n}\n```\n\n## Controller\n一般使用`Spring`框架的`RestController`向前端提供接口，根据不同的接口类型添加`@PostMapping`、`@GetMapping`等注解。同时通过`Swagger UI`展示和调试接口。\n\n> MonitoringDeviceController.java\n```java\n@RestController\n@RequestMapping(\"demo/device\")\n@Api(value = \"demo/device\", tags = \"测量设备接口\")\npublic class MonitoringDeviceController {\n    @Autowired\n    private MonitoringDeviceService deviceService;\n\n    @PostMapping(\"add\")\n    @ApiOperation(value = \"新增设备\")\n    public Result<Boolean> addDevice(@RequestBody @Validated AddMonitoringDeviceReq device) {\n        return Result.ok(deviceService.addDevice(device));\n    }\n\n    @PutMapping(\"edit\")\n    @ApiOperation(value = \"编辑设备\")\n    public Result<MonitoringDeviceDTO> editDevice(@RequestBody EditMonitoringDeviceReq device) {\n        return Result.ok(deviceService.editDevice(device));\n    }\n\n    @GetMapping(\"getById\")\n    @ApiOperation(value = \"获取设备\")\n    public Result<MonitoringDeviceDTO> getDeviceById(@RequestParam Long deviceId) {\n        return Result.ok(deviceService.getDeviceById(deviceId));\n    }\n\n    @DeleteMapping(\"delete\")\n    @ApiOperation(value = \"删除设备\")\n    public Result<Boolean> deleteDevice(@RequestParam Long deviceId) {\n        return Result.ok(deviceService.deleteDevice(deviceId));\n    }\n}\n```\n\n# 条件构造器的其他方法\n| 方法名         | SQL                      | 实例                                                             | SQL实例                                              |\n|:------------|:-------------------------|:---------------------------------------------------------------|:---------------------------------------------------|\n| eq          | 等于=                      | eq(\"name\", \"老王)                                                | name = '老王'                                        |\n| ne          | 不等于<>                    | ne(\"name\", \"老王)                                                | name <> '老王'                                       |\n| gt          | 大于>                      | gt(\"age\", 18)                                                  | age > 18                                           |\n| e           | 大于等于>=                   | ge(\"age\", 18)                                                  | age >= 18                                          |\n| t           | 小于<                      | It(\"age\", 18)                                                  | age < 18                                           |\n| e           | 小于<=                     | le(\"age\", 18)                                                  | age <= 18                                          |\n| between     | BETWEEN 值1 AND 值2        | between(\"age\", 18, 30)                                         | age between 18 and 30                              |\n| notBetween  | NOT BETWEEN 值1 AND 值2    | notBetween(\"age\", 18, 30)                                      | age not between 18 and 30                          |\n| like        | LIKE '%值%'               | like(\"name\", \"王\")                                              | name like '%王%'                                    |\n| notLike     | NOT LIKE '%值%'           | notLike(\"name\", \"王\")                                           | name not like '%王%'                                |\n| likeLeft    | LIKE '%值'                | likeLeft(\"name\", \"王\")                                          | name like '%王'                                     |\n| likeRight   | LIKE '值%'                | likeRight(\"name\", \"王\")                                         | name like '王%'                                     |\n| isNull      | 字段 IS NULL               | isNull(\"name\")                                                 | name is null                                       |\n| isNotNull   | 字段 IS NOT NULL           | isNotNull(\"name\")                                              | name is not null                                   |\n| in          | 字段 IN (v0, v1, ...)      | in(\"age\", {1, 2, 3})                                           | age in (1, 2, 3)                                   |\n| notIn       | 字段 NOT IN (v0, v1, ...)  | notIn(\"age\", {1, 2, 3})                                        | age not in (1, 2, 3)                               |\n| inSql       | 字段 IN(sql语句)             | inSql(\"id\", \"select id from table where id < 3\")               | id in (select id from table where id < 3)          |\n| notInSql    | 字段 NOT IN (sql语句)        | notInSql(\"id\", \"select id from table where id < 3\")            | age not in (select id from table where id < 3)     |\n| groupBy     | 分组 GROUP BY 字段, ...      | groupBy(\"id\", \"name\")                                          | group by id, name                                  |\n| orderByAsc  | 排序 ORDER BY 字段, ... ASC  | orderByAsc(\"id\", \"name\")                                       | order by id ASC, name ASC                          |\n| orderByDesc | 排序 ORDER BY 字段, ... DESC | orderByDesc(\"id\", \"name\")                                      | order by id DESC, name DESC                        |\n| orderBy     | 排序 ORDER BY 字段, ...      | orderBy(true, true, \"id\", \"name\")                              | order by id ASC, name ASC                          |\n| having      | HAVING (sql语句)           | having(\"sum(age) > {0}\", 11)                                   | having sum(age) > 11                               |\n| or          | 拼接 OR                    | eq(\"id\", 1).or().eq(\"name\", \"老王\")                              | id = 1 or name = '老王                               |\n| and         | AND 嵌套                   | and(i -> i.eq(\"name\", \"李白\").ne(\"status\", \"活着\"))                | and (name = '李白' and status <> '活着')               |\n| apply       | 拼接sql                    | apply(\"date_format(dateColumn, '%Y-%m-%d')={0}\", \"2008-08-08\") | date_format(dateColumn,'%Y-%m-%d') = '2008-08-08') |\n| last        | 无视优化规则直接拼接到sql的最后        | last(\"limit 1\")                                                |                                                    |\n| exists      | 拼接 EXISTS (sql语句)        | exists(\"select id from table where age = 1\")                   | exists (select id from table where age = 1)        |\n| notExists   | 拼接 NOT EXISTS (sql语句)    | notExists(\"select id from table where age = 1\")                | not exists (select id from table where age = 1)    |\n| nested      | 正常嵌套不带AND或者0R            | nested(i -> i.eq(\"name\", \"李白\"). ne(\"status\", \"活着\"))            | (name = '李白' and status <> '活着')                   |\n\n# 小结\n- `MyBatis-Plus`从数据库表到前端接口的业务流程是`数据库表->DTO->Mapper->Service->Controller`；\n- `DTO`是数据传输对象，表示数据库里的关系数据；\n- `Mapper`封装了基础的`CRUD`接口，提供了基础的数据库操作；\n- `Service`在`Mapper`的基础上提供条件构造器，便于我们编写复杂的数据库操作；\n- `Controller`将接口提供给前端调用，通常使用`Spring`提供的`RestController`。\n\n---\n**非常感谢你的阅读，辛苦了！**\n\n---\n参考文章： (感谢以下资料提供的帮助)\n- [ORM框架简介](https://blog.csdn.net/papima/article/details/78219000)\n- [MyBatis-Plus LambdaQueryWrapper使用说明](https://blog.csdn.net/qlzw1990/article/details/116996422)\n- [MyBatis plus 之 QueryWrapper、LambdaQueryWrapper、LambdaQueryChainWrapper](https://adong.blog.csdn.net/article/details/122154137)\n","tags":["后端","Java","MyBatis-Plus"],"categories":["学习笔记"]},{"title":"Java函数式编程学习笔记（二）","url":"/posts/6ccb0645c089.html","content":"# 前言\n上次我们谈到，在Java代码中使用`Lambda`可以显著减少代码量，提高开发效率。那么在Java项目开发过程中，还有一个非常好用的接口：`Stream Api`，我们叫它`Stream`流。\n\n> 注意：这个`Stream`不同于`java.io`的`InputStream`和`OutputStream`，它代表的是若干个任意Java对象元素的序列，这一点特性和`Collection`有点相似，但是`Stream`并不会真正存储这些元素，而是根据需要来实时计算和存储，真正的计算通常发生在最终结果的输出，是一种`惰性计算`。\n\n`Stream`使用一种类似用`SQL`语句从数据库查询数据的直观方式来提高Java集合运算逻辑的编码效率，让我们能够写出**高效率**、**干净**、**简洁**的代码。在使用它的时候，我感受到了前所未有的便利。\n\n# Stream流\n## 什么是Stream？\n`Stream`是一个来自数据源的元素队列并支持转换与聚合操作。\n\n- **元素**是特定类型的对象，它们形成一个队列。Java中的`Stream`并不会存储元素，而是按需计算。\n- **数据源**是流的来源。可以是`集合`，`数组`，`I/O channel`，产生器`generator`等。\n- **转换操作**与**聚合操作**是类似SQL语句一样的操作，可以使用`map`, `filter`, `reduce`, `find`, `match`, `sorted`等方法将一个`Stream`转换成另一个`Stream`。\n\n`Stream`还有两个区别于`Collection`的基本特征：\n\n- **Pipelining**: 中间操作都会返回一个流对象，而不是最终的集合等结构。这样多个操作可以串联成一个管道，如同流式风格(`fluent style`)。这样做可以对操作进行优化，比如延迟执行(`laziness`)和短路(`short-circuiting`)。\n- **内部迭代**： 以前我们对集合遍历都是通过`Iterator`或者`For-Each`代码块的方式, 显式的在集合外部进行迭代，这叫做外部迭代。`Stream`提供了内部迭代的方式，通过上面介绍的**转换与聚合操作**实现。\n\n## 创建Stream\n我们可以通过许多方式将常见的结构转换成`Stream`来使用。\n\n### Stream.of()\n创建`Stream`最简单的方式是直接用`Stream.of()`静态方法，传入可变参数即创建了一个能输出确定元素的`Stream`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<String> stream = Stream.of(\"A\", \"B\", \"C\", \"D\");\n        // forEach()方法相当于内部循环调用，\n        // 可传入符合Consumer接口的void accept(T t)的方法引用：\n        stream.forEach(System.out::println);\n    }\n}\n```\n\n虽然这种方式基本上没啥实质性用途，但测试的时候很方便。\n\n### 基于数组或Collection\n第二种创建`Stream`的方法是基于一个数组或者`Collection`，这样该`Stream`输出的元素就是数组或者Collection持有的元素：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<String> stream1 = Arrays.stream(new String[] { \"A\", \"B\", \"C\" });\n        Stream<String> stream2 = List.of(\"X\", \"Y\", \"Z\").stream();\n        stream1.forEach(System.out::println);\n        stream2.forEach(System.out::println);\n    }\n}\n```\n\n事实上，所有`Collection`都可以轻松地转换成`Stream`，只需调用`stream()`方法即可。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        Stream<String> stream1 = list.stream();\n        Set<String> set = new HashSet<>();\n        Stream<String> stream2 = set.stream();\n        Vector<String> vector = new Vector<>();\n        Stream<String> stream3 = vector.stream();\n    }\n}\n```\n上述两种创建`Stream`的方法都是把一个现有的序列变为`Stream`，它的元素是固定的。\n\n### 基于Supplier\n创建`Stream`还可以通过`Stream.generate()`方法，它需要传入一个`Supplier`对象：\n\n```java\nStream<String> s = Stream.generate(Supplier<String> sp);\n```\n\n基于`Supplier`创建的`Stream`会不断调用`Supplier.get()`方法来不断产生下一个元素，这种`Stream`保存的不是元素，而是算法，它可以用来表示无限序列。\n\n例如，我们编写一个能不断生成自然数的`Supplier`，它的代码非常简单，每次调用`get()`方法，就生成下一个自然数：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<Integer> natual = Stream.generate(new NatualSupplier());\n        // 注意：无限序列必须先变成有限序列再打印:\n        natual.limit(20).forEach(System.out::println);\n    }\n}\n\nclass NatualSupplier implements Supplier<Integer> {\n    int n = 0;\n    public Integer get() {\n        n++;\n        return n;\n    }\n}\n```\n\n> 因为Java的范型不支持基本类型，所以我们无法用`Stream<int>`这样的类型，会发生编译错误。为了保存`int`，只能使用`Stream<Integer>`，但这样会产生频繁的装箱、拆箱操作。为了提高效率，Java标准库提供了`IntStream`、`LongStream`和`DoubleStream`这三种使用基本类型的`Stream`，它们的使用方法和范型`Stream`没有大的区别，设计这三个`Stream`的目的是提高运行效率。\n\n## 操作Stream\n前面提到，我们可以通过一些转换与聚合操作对`Stream`进行一些处理，来达到处理数据的目的。我们通常把`Stream`的操作写成**链式操作**，这样显得代码更简洁。\n\n### 使用map\n`map`方法是最常用的转换操作。它能够把一种操作运算，映射到一个序列的每一个元素上，可以将一种元素类型转换成另一种元素类型。\n\n例如，对`x`计算它的平方，可以使用函数`f(x) = x * x`。我们把这个函数映射到一个序列`1，2，3，4，5`上，就得到了另一个序列`1，4，9，16，25`：\n\n```java\nStream<Integer> s1 = Stream.of(1, 2, 3, 4, 5);\nStream<Integer> s2 = s1.map(n -> n * n);\n```\n\n利用`map()`，不但能完成数学计算，对于字符串操作，以及任何Java对象都是非常有用的。例如：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List.of(\"  Apple \", \" pear \", \" ORANGE\", \" BaNaNa \")\n                .stream()\n                .map(String::trim) // 去空格\n                .map(String::toLowerCase) // 变小写\n                .forEach(System.out::println); // 打印\n    }\n}\n```\n\n### 使用filter\n`filter()`是另一种转换操作，它能够对一个`Stream`的每个元素进行判断，不满足条件的就被过滤掉了，剩下的满足条件的元素就构成了一个新的`Stream`。\n\n例如，我们对`1，2，3，4，5`这个`Stream`调用`filter()`，传入的测试函数`f(x) = x % 2 != 0`用来判断元素是否是奇数，这样就过滤掉偶数，只剩下奇数，因此我们得到了另一个序列`1，3，5`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        IntStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)\n                .filter(n -> n % 2 != 0)\n                .forEach(System.out::println);\n    }\n}\n```\n\n`filter()`除了常用于数值外，也可应用于任何Java对象。例如，从一组给定的`LocalDate`中过滤掉工作日，以得到休息日：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream.generate(new LocalDateSupplier())\n                .limit(31)\n                .filter(ldt -> ldt.getDayOfWeek() == DayOfWeek.SATURDAY || ldt.getDayOfWeek() == DayOfWeek.SUNDAY)\n                .forEach(System.out::println);\n    }\n}\n\nclass LocalDateSupplier implements Supplier<LocalDate> {\n    LocalDate start = LocalDate.of(2020, 1, 1);\n    int n = -1;\n    public LocalDate get() {\n        n++;\n        return start.plusDays(n);\n    }\n}\n```\n\n### 使用reduce\n`reduce()`是一种聚合操作，它可以把一个`Stream`的所有元素按照聚合函数聚合成一个结果。我们以一个简单的求和运算为例：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)\n                .reduce(0, (acc, n) -> acc + n);\n        System.out.println(sum); // 45\n    }\n}\n```\n\n可见，`reduce()`方法有两个参数，第一个参数是一个初始值，第二个参数是聚合函数。`reduce()`操作首先初始化结果为指定值（这里是`0`），紧接着，`reduce()`对每个元素依次调用`(acc, n) -> acc + n`，其中，`acc`是上次计算的结果。\n\n我们还可以把求和改成求积，代码也十分简单：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int s = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)\n                .reduce(1, (acc, n) -> acc * n);\n        System.out.println(s); // 362880\n    }\n}\n```\n\n> 注意：计算求积时，初始值必须设置为`1`。\n\n除了可以对数值进行累积计算外，灵活运用`reduce()`也可以对Java对象进行操作。下面的代码演示了如何将配置文件的每一行配置通过`map()`和`reduce()`操作聚合成一个`Map<String, String>`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 按行读取配置文件:\n        List<String> props = List.of(\"profile=native\", \"debug=true\", \"logging=warn\", \"interval=500\");\n        Map<String, String> map = props.stream()\n                // 把k=v转换为Map[k]=v:\n                .map(kv -> {\n                    String[] ss = kv.split(\"\\\\=\", 2);\n                    return Map.of(ss[0], ss[1]);\n                })\n                // 把所有Map聚合到一个Map:\n                .reduce(new HashMap<String, String>(), (m, kv) -> {\n                    m.putAll(kv);\n                    return m;\n                });\n        // 打印结果:\n        map.forEach((k, v) -> {\n            System.out.println(k + \" = \" + v);\n        });\n    }\n}\n```\n\n### 其他操作\n除了前面介绍的常用操作外，`Stream`还提供了一系列非常有用的方法。\n\n#### 排序\n对`Stream`的元素进行排序十分简单，只需调用`sorted()`方法：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"Orange\", \"apple\", \"Banana\")\n            .stream()\n            .sorted()\n            .collect(Collectors.toList());\n        System.out.println(list);\n    }\n}\n```\n\n此方法要求`Stream`的每个元素必须实现`Comparable`接口。如果要自定义排序，传入指定的`Comparator`即可：\n\n```java\nList<String> list = List.of(\"Orange\", \"apple\", \"Banana\")\n    .stream()\n    .sorted(String::compareToIgnoreCase)\n    .collect(Collectors.toList());\n```\n\n#### 去重\n对一个`Stream`的元素进行去重，可以直接用`distinct()`：\n\n```java\nList.of(\"A\", \"B\", \"A\", \"C\", \"B\", \"D\")\n    .stream()\n    .distinct()\n    .collect(Collectors.toList()); // [A, B, C, D]\n```\n\n#### 截取\n截取操作常用于把一个无限的`Stream`转换成有限的`Stream`，`skip()`用于跳过当前`Stream`的前`N`个元素，`limit()`用于截取当前`Stream`最多前`N`个元素：\n\n```java\nList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\")\n    .stream()\n    .skip(2) // 跳过A, B\n    .limit(3) // 截取C, D, E\n    .collect(Collectors.toList()); // [C, D, E]\n```\n\n#### 合并\n将两个`Stream`合并为一个`Stream`可以使用`Stream`的静态方法`concat()`：\n\n```java\nStream<String> s1 = List.of(\"A\", \"B\", \"C\").stream();\nStream<String> s2 = List.of(\"D\", \"E\").stream();\n// 合并:\nStream<String> s = Stream.concat(s1, s2);\nSystem.out.println(s.collect(Collectors.toList())); // [A, B, C, D, E]\n```\n\n#### flatMap\n如果`Stream`的元素是集合：\n\n```java\nStream<List<Integer>> s = Stream.of(\n        Arrays.asList(1, 2, 3),\n        Arrays.asList(4, 5, 6),\n        Arrays.asList(7, 8, 9));\n```\n\n由上面三个`List`组成的`Stream`形成了一个二维数组的形式，而我们希望把上述`Stream`转换为`Stream<Integer>`，就可以使用`flatMap()`：\n```java\nStream<Integer> i = s.flatMap(list -> list.stream());\n```\n因此，所谓`flatMap()`，是指把`Stream`的每个元素（这里是`List`）映射为`Stream`，然后合并成一个新的`Stream`，即把二维数组转成一维的。\n\n#### 并行\n通常情况下，对`Stream`的元素进行处理是单线程的，即一个一个元素进行处理。但是很多时候，我们希望可以并行处理`Stream`的元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。\n\n把一个普通`Stream`转换为可以并行处理的`Stream`非常简单，只需要用`parallel()`进行转换：\n\n```java\nStream<String> s = ...\nString[] result = s.parallel() // 变成一个可以并行处理的Stream\n        .sorted() // 可以进行并行排序\n        .toArray(String[]::new);\n```\n\n或者直接在创建`Stream`时使用`parallelStream()`方法，为集合创建并行流：\n\n```java\nList list = ...\nStream<String> s = list.parallelStream() // 生成一个可以并行处理的Stream\n        .sorted() // 可以进行并行排序\n```\n\n#### 其他聚合方法\n除了`reduce()`和`collect()`外，`Stream`还有一些常用的聚合方法：\n\n- `count()`：用于返回元素个数；\n- `max(Comparator<? super T> cp)`：找出最大元素；\n- `min(Comparator<? super T> cp)`：找出最小元素。\n\n针对`IntStream`、`LongStream`和`DoubleStream`，还额外提供了以下聚合方法：\n\n- `sum()`：对所有元素求和；\n- `average()`：对所有元素求平均数。\n\n还有一些方法，用来测试`Stream`的元素是否满足以下条件：\n\n- `boolean allMatch(Predicate<? super T>)`：测试是否所有元素均满足测试条件；\n- `boolean anyMatch(Predicate<? super T>)`：测试是否至少有一个元素满足测试条件。\n\n最后一个常用的方法是`forEach()`，它可以循环处理`Stream`的每个元素，我们经常传入`System.out::println`来打印`Stream`的元素：\n\n```java\nStream<String> s = ...\ns.forEach(str -> {\n    System.out.println(\"Hello, \" + str);\n});\n```\n\n## 输出Stream\n我们使用`Stream`对数据进行了处理，最后就需要输出`Stream`里的元素了。\n\n在此之前，我们先对之前介绍的操作分个类：一类是转换操作，即把一个`Stream`转换为另一个`Stream`，例如`map()`和`filter()`，另一类是聚合操作，即对`Stream`的每个元素进行计算，得到一个确定的结果，例如`reduce()`。\n\n大家有没有注意到，在介绍`reduce()`方法时，我们用`reduce()`编写了求和与求积运算，它们返回的并不是另一个`Stream`，而是一个值`sum`。因此，上面两种操作的区别就是：转换操作并不会触发任何计算；而聚合操作会立刻促使`Stream`输出它的每一个元素，并依次纳入计算，以获得最终结果。所以，我们可以使用聚合操作输出`Stream`。\n\n### 输出为List\n`reduce()`只是一种聚合操作，如果我们希望把`Stream`的元素保存到集合，例如`List`，因为`List`的元素是确定的Java对象，因此，把`Stream`变为`List`不是一个转换操作，而是一个聚合操作，它会强制`Stream`输出每个元素。\n\n下面的代码演示了如何将一组`String`先过滤掉空字符串，然后把非空字符串保存到`List`中：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<String> stream = Stream.of(\"Apple\", \"\", null, \"Pear\", \"  \", \"Orange\");\n        List<String> list = stream.filter(s -> s != null && !s.isBlank()).collect(Collectors.toList());\n        System.out.println(list);\n    }\n}\n```\n\n把Stream的每个元素收集到`List`的方法是调用`collect()`并传入`Collectors.toList()`对象，它实际上是一个`Collector`实例，通过类似`reduce()`的操作，把每个元素添加到一个收集器中，这里实际上是`ArrayList`。\n\n类似的，`collect(Collectors.toSet())`可以把`Stream`的每个元素收集到`Set`中。\n\n### 输出为数组\n把Stream的元素输出为数组和输出为`List`类似，我们只需要调用`toArray()`方法，并传入数组的*构造方法*：\n\n```java\nList<String> list = List.of(\"Apple\", \"Banana\", \"Orange\");\nString[] array = list.stream().toArray(String[]::new);\n```\n\n注意到传入的*构造方法*是`String[]::new`，它的签名实际上是`IntFunction<String[]>`定义的`String[] apply(int)`，即传入`int`参数，获得`String[]`数组的返回值。\n\n### 输出为Map\n如果我们要把`Stream`的元素收集到`Map`中，就稍微麻烦一点。因为对于每个元素，添加到`Map`时都需要`key`和`value`，因此，我们要指定两个映射函数，分别把元素映射为`key`和`value`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"Apple\", \"Banana\", \"Blackberry\", \"Coconut\", \"Avocado\", \"Cherry\", \"Apricots\");\n        Map<String, List<String>> groups = list.stream()\n                .collect(Collectors.groupingBy(s -> s.substring(0, 1), Collectors.toList()));\n        System.out.println(groups);\n    }\n}\n```\n\n### 分组输出\n`Stream`还有一个强大的分组功能，可以按组输出。我们看下面的例子：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"Apple\", \"Banana\", \"Blackberry\", \"Coconut\", \"Avocado\", \"Cherry\", \"Apricots\");\n        Map<String, List<String>> groups = list.stream()\n                .collect(Collectors.groupingBy(s -> s.substring(0, 1), Collectors.toList()));\n        System.out.println(groups);\n    }\n}\n```\n分组输出使用`Collectors.groupingBy()`，它需要提供两个函数：一个是分组的`key`，这里使用`s -> s.substring(0, 1)`，表示只要首字母相同的`String`分到一组，第二个是分组的`value`，这里直接使用`Collectors.toList()`，表示输出为`List`，上述代码运行结果如下：\n\n> A=[Apple, Avocado, Apricots],  \n> B=[Banana, Blackberry],  \n> C=[Coconut, Cherry]  \n\n## 小结\n`Stream`提供的常用操作有：\n\n| 类型   | 方法                                                                   |\n|:-----|:---------------------------------------------------------------------|\n| 转换操作 | `map()`，`filter()`，`sorted()`，`distinct()`                           |\n| 合并操作 | `concat()`，`flatMap()`                                               |\n| 并行处理 | `parallel()`                                                         |\n| 聚合操作 | `reduce()`，`collect()`，`count()`，`max()`，`min()`，`sum()`，`average()` |\n| 其他操作 | `allMatch()`，`anyMatch()`，`forEach()`                                |\n\n# 应用\n## 需求规格\n在项目中，需要编写这样的业务逻辑：根据一串`id`在数据库中查询并返回与`id`匹配的数据；或者再复杂一些，在一个表中根据`id`查到数据，然后根据这些数据的其他字段查询另一个表的数据。在这些逻辑中，需要保证代码拥有较高的可读性和健壮性，保证数据库表或者`DTO`入参产生变化时，相应的业务代码不需要做大的改动。\n\n## 解决方案\n使用`Stream`代替`for`循环遍历数组，使用`map`可以从数据库表一行数据里提取出一个`id`字段，再用`collect`将其转换为`List`。\n\n使用`Stream`存储`id`时，如果用这些`id`查询到了多行数据，有可能会返回由`List`组成的`Stream`，这时就可以用`flatMap`，将它们转换成单行数据组成的`Stream`。\n\n## 实例\n假设已得到一个实体数组：\n```java\nList<EmissionCalcParamDTO> emissionCalcParams\n```\n\n我们可以使用`Stream`轻松地获取这些实体的`id`，只需在`map`中传入`getter`方法：\n\n```java\nList<Long> paramIdList = emissionCalcParams.stream()\n        .map(EmissionCalcParamDTO::getId)\n        .collect(Collectors.toList());\n```\n\n之后，可以根据这些`id`在数据库中查询另一个表的数据，这里使用了MyBatis-Plus的条件构造器编写查询条件。\n\n```java\nList<DetermineDTO> determineList = new LambdaQueryChainWrapper<>(determineMapper)\n        .eq(DetermineDTO::getObtainingMethod, 2)\n        .in(DetermineDTO::getCalcParamId, paramIdList)\n        .list();\n```\n\n最后，根据这些数据里的字段，返回第三个表的数据：\n\n```java\nreturn determineList.stream()\n        .map(DetermineDTO::getDeviceId)\n        .map(this::getDeviceById)\n        .collect(Collectors.toList());\n```\n\n可以注意到，这些`map`传入了`getter`方法和内部方法，对`Stream`进行多次转换，最终得到我们想要的结果。\n\n再来看另一个实例。这次我们根据id获取到的数据是由`List`组成的，需要将它们转换成单行数据，即去除它们的分组。我们可以使用`flatMap`，把`Stream`的每个`List`映射为`Stream`，然后合并成一个新的`Stream`，只需传入`Collection`的内部方法`stream()`即可。\n\n```java\nreturn deviceList.stream().map(MonitoringDeviceDTO::getId)\n        .map(this::getRecordByDevice)\n        .flatMap(Collection::stream)\n        .collect(Collectors.toList());\n```\n\n# 题外话\n我编写Java代码使用的`IDE`是`IntelliJ IDEA`。在编写`Stream`的链式操作时适当换行，`IDEA`可以将每一行链式操作得到的**数据类型**显示在行末，清晰地展现出`Stream`的`Pipelining`特点，非常有助于阅读和编写代码。\n\n此外，`IDEA`内置的`Lombok`插件（小辣椒）可以自动生成类的`getter`与`setter`方法，不需要手动重复编写，需要时直接调用就好，且代码自动补全功能会在这些自动生成的方法图标右下角显示一个小辣椒，非常有趣。\n\n---\n**非常感谢你的阅读，辛苦了！**\n\n---\n参考文章： (感谢以下资料提供的帮助)\n- [使用Stream - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1252599548343744/1322402873081889)\n- [Java 8 Stream | 菜鸟教程](https://www.runoob.com/java/java8-streams.html)\n","tags":["后端","Java","Stream"],"categories":["学习笔记"]},{"title":"如何在不同电脑上使用SSH访问同一个代码库","url":"/posts/acc0fec61eb5.html","content":"# 前言\n最近在使用Git的过程中遇到了这样一个场景：我们有时需要在**不同电脑**上使用SSH访问**同一个代码库**，但每台电脑又有各自其他的用途。使用SSH访问代码托管平台时要生成密钥对，但又需要输入一个邮箱。\n\n大家有没有想过，我们在代码托管平台、Git本地库和生成SSH密钥对时都要输入一个邮箱用作用户名，这些邮箱有区别吗？生成SSH密钥对时输入什么邮箱比较合适？输入别的字符可以吗？如何让一台电脑能用**不同用户名**访问**不同的代码库**呢？下面，我们就来探讨一下这些问题。\n\n# SSH密钥\n大多数Git教程都会告诉你，生成SSH密钥时在`-C`后输入你在Git中设置`user.email`那里填写的邮箱就可以了，而且在很多教程里都会看到这行命令：\n\n```powershell\nssh-keygen -t rsa -C \"username@email.com\"\n```\n\n你看，命令都是这么写的，让你输入一个邮箱，是吧。\n\n事实上，ssh-keygen命令中常用的参数是这样解释的：\n\n| 参数  | 解释                            |\n|:----|:------------------------------|\n| -t  | 指定要创建的密钥类型，一般采用rsa加密方式，另外有dsa |\n| -b  | 指定密钥长度，rsa默认2048bit           |\n| -f  | 指定用来保存密钥的文件名，可以不指定            |\n| -C  | 添加备注                          |\n\n我们尝试输入这行命令：\n\n```powershell\nssh-keygen -t rsa -C \"username@email.com\"\n```\n\n以上命令省略了-f参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的SSH key代码，你一般会看到如下的文字：\n\n```powershell\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/Users/yourusername/.ssh/id_rsa): [Press enter]\n```\n\n不输入文件名，按下回车后，会在你电脑的User文件夹的`.ssh`路径下创建一个加密方式为`rsa`、注释为`username@email.com`的SSH密钥，而且会同时生成一对公钥和私钥，文件名为`id_rsa`，公钥的文件后缀名为`.pub`，私钥没有后缀名。\n\n因此，在生成SSH密钥时，输入邮箱只是起到一个**备注**的作用，填写其他**任意内容**均可，也跟你的Git用户名**没有任何关系**。一台电脑使用**一个**SSH密钥就能访问**多个**远程服务器。\n\n# 合理使用注释\n那么，我们该如何填写注释，在日常使用中更方便地区分它们呢？\n\n我列举这样一个场景：我在公司使用台式机办公，同时家里有一台台式机，自己有一台笔记本电脑。我有一些个人的兴趣性项目，代码托管在GitHub上，同时有一些公司的项目，代码托管在公司服务器上。我会在公司电脑上使用SSH访问公司服务器的代码库，并且偶尔需要用公司电脑访问自己的个人代码；在家里会使用台式机和笔记本访问自己的GitHub。\n\n用表格列举如下：\n\n| 电脑名称      | 说明        |\n|:----------|:----------|\n| HomePC    | 家中使用的台式电脑 |\n| CompanyPC | 公司使用的台式电脑 |\n| Laptop    | 自己的笔记本电脑  |\n\n| 代码托管平台 | 用户名      | email              | 说明   |\n|:-------|:---------|:-------------------|:-----|\n| GitHub | personal | personal@qq.com    | 个人邮箱 |\n| 公司服务器  | company  | company@company.cn | 公司邮箱 |\n\n从某种角度上看，我们的代码库和开发环境存在**多对多**的关联关系，三乘以二等于六，是不是我们也要创建6个SSH密钥对呢？不是的。\n\n我们需要留意到，在设置Git用户名和密码时，我们总是添加`-global`参数，让计算机上所有的Git库都使用同一个用户名。因此，我们完全可以在某些本地库中设置**单独**的用户名和密码，来访问特定的远程库。\n\n以上面的情况为例，我们可以给每台电脑只创建一个SSH密钥对，在公司台式机上针对个人代码的**本地库**设置Git用户名为`personal@qq.com`，**全局**用户名设置为`company@company.cn`，然后在家里的台式机和笔记本上设置**全局**用户名为`personal@qq.com`。\n\n最后，在设置好Git用户名之后，给各台电脑的密钥对添加注释，填写**每台电脑的名称**，而不是邮箱。用表格列举如下：\n\n| 电脑名称      | 密钥对注释          | 代码托管网站上显示密钥标题 |\n|:----------|:---------------|:--------------|\n| HomePC    | -C \"HomePC\"    | HomePC        |\n| CompanyPC | -C \"CompanyPC\" | CompanyPC     |\n| Laptop    | -C \"Laptop\"    | Laptop        |\n\n理清关系后，我们发现，SSH密钥对其实是与**每台电脑**关联的，而非Git用户。把密钥添加到代码托管网站上的时候，最好用一个跟这台电脑密切相关的注释。以后如果不使用这台电脑了，从网站上删除这个密钥很方便。\n> 这里需要注意的是代码托管网站对本地设定的Git用户是如何处理的。代码托管网站主要关注Git用户名`user.email`，用`user.email`来匹配托管平台账户名的**邮件地址**，如果相同，代码托管网站就认为此操作是账户所有者的操作。下面举一个例子：  \n如果本地设定的`user.email`是`personal@qq.com`，由于在GitHub账户的邮件地址也是`personal@qq.com`，如果从这台电脑push的话，GitHub会认定这次push是账户拥有者自己做的；如果本地设定的`user.email`是`company@company.cn`，也能push到GitHub，但GitHub会记录这次的修改是另一个用户名为`company`的人做的。\n\n# 小结\n- 使用ssh-keygen命令产生密钥对，每台电脑有**一对**就够了。\n\n- 在本地生成ssh密钥对时，推荐用**计算机相关信息**而不是用户名作为密钥对的注释。在代码托管网站上，也推荐用这个信息来做密钥对的标题。\n\n- 配置本地Git用户名时，全局配置（`–global`）要考虑该电脑上的工作主要push到哪个远程服务器，然后配置成跟那个服务器一致的用户名和邮件地址。\n\n- 除了主要push的服务器外，如果这台电脑上的工作还需要push到其他服务器，那么在具体的本地库目录下，把用户名和邮件地址配置成与特定服务器相同即可。\n\n经过上面的操作，我们可以愉快地在不同的电脑上用相同的账户访问同一个代码库，同时不影响电脑其他的工作，并且能够更加清晰地分辨每个SSH密钥的用途。\n\n---\n**非常感谢你的阅读，辛苦了！**\n\n---\n参考文章： (感谢以下资料提供的帮助)\n- [Git教程 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/896043488029600)\n- [ssh-keygen命令详解](https://blog.csdn.net/qq_40932679/article/details/117487540)\n- [对Git用户名与Github账户关系的理解](https://blog.csdn.net/belongtocode/article/details/100716812)\n","tags":["Git","SSH"],"categories":["经验分享"]},{"title":"Java函数式编程学习笔记（一）","url":"/posts/a798ff4a2a23.html","content":"# 前言\n最近在项目中需要使用一些基于MyBatis-Plus封装的CRUD接口，阅读一些文档和代码后发现在Java代码中偶尔会见到C++代码里的**类作用域符号**`::`和`->`**运算符**，查阅资料才了解到这两个符号在Java领域里属于函数式编程的语法内容，于是写下这篇博客以记录这段时间的学习过程。\n\n# Java函数式编程\n## 什么是函数式编程？\n函数式编程是一种**抽象程度很高**的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种函数我们称为**没有副作用的函数**。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是**有副作用的**。\n\n函数式编程的一个特点就是，允许把**函数本身**作为参数传入另一个函数，还允许返回一个函数。函数式编程是把函数作为**基本运算单元**，函数可以作为变量，可以接收函数，还可以返回函数。\n\n历史上研究函数式编程的理论是**Lambda演算**，所以我们经常把支持函数式编程的编码风格称为**Lambda表达式**。\n\n## Lambda表达式\nLambda表达式是表示可传递**匿名函数**的一种简洁方式，Lambda表达式没有名称，但是有参数列表、函数主体、返回类型，还可能有一个可以抛出的异常列表。它是Java 8新增的特性，有了它，我们再也不用像以前那样写一堆笨重的匿名类代码了。\n\n在Java中，我们经常遇到**单方法接口**，即***一个接口***只定义了***一个方法***，例如：\n\n> - Comparator\n>\n> - Runnable\n>\n> - Callable\n\n对于单方法接口，我们称之为`FunctionalInterface`，用**注解**`@FunctionalInterface`标记。以`Comparator`为例，我们想要调用`Arrays.sort()`时，可以传入一个`Comparator`实例，以匿名类方式编写如下：\n\n```java\nArrays.sort(array, new Comparator<String>() {\n　　public int compare(String s1, String s2) {\n　　    return s1.compareTo(s2);\n　　}\n});\n```\n\n上述写法非常繁琐。从Java 8开始，我们可以用Lambda表达式替换单方法接口。改写上述代码如下：\n\n```java\nArrays.sort(array, (s1, s2) -> {\n　　return s1.compareTo(s2);\n});\n```\n\n观察Lambda表达式的写法，它只需要写出**方法定义**：\n\n```java\n(s1, s2) -> {\n　　return s1.compareTo(s2);\n}\n```\n\n其中，参数是`(s1, s2)`，参数类型可以省略，因为编译器可以**自动推断出`String`类型**。`-> { ... }`表示方法体，所有代码写在内部即可。Lambda表达式没有`class`定义，因此写法非常简洁。\n\n如果只有一行`return ...`的代码，可以用更简单的写法，即**省略方法体的括号**：\n\n```java\nArrays.sort(array, (s1, s2) -> s1.compareTo(s2));\n```\n\n## 方法引用\n方法引用是Java8中引入的新特性，它提供了一种**引用方法而不执行方法**的方式，可以让我们重复使用现用方法的定义，作为某些Lambda表达式的另一种更简洁的写法。\n\n当你需要方法引用时，将目标引用放在**分隔符**`::`前，方法的名称放在**分隔符**`::`后。方法名称后**不需要加括号**，因为我们并没有实际调用它。方法引用提高了代码的可读性，也使逻辑更加清晰。\n\n可以构建方法引用的场景有四种：\n\n### 静态方法\n指向**静态方法**的引用，语法：`类名::静态方法名`，类名放在**分隔符**`::`前，静态方法名放在**分隔符**`::`后。例如：\n\n```java\n(String str) -> Integer.parseInt(str)\n```\n\n使用方法引用以后，可以简写为：\n\n```java\nInteger::parseInt\n```\n\n### 内部对象的实例方法\n指向Lambda表达式**内部对象**的实例方法的引用，语法：`类名::实例方法名`，类名放在**分隔符**`::`前，实例方法名放在**分隔符**`::`后。例如：\n\n```java\n(Equipment equipment) -> equipment.getBrand()\n```\n\n使用方法引用以后，可以简写为：\n\n```java\nEquipment::getBrand\n```\n\n### 外部对象的实例方法\n指向Lambda表达式**外部对象**的实例方法的引用，语法：`实例名::实例方法名`，类名放在**分隔符**`::`前，实例方法名放在**分隔符**`::`后。例如：\n\n```java\nString type = \"STR\";\nPredicate<String> predicate = (String str) -> type.equals(str);\nSystem.out.println(predicate.test(\"STR\"));\n```\n\n其中，`type`是一个Lambda表达式外部的局部变量，使用方法引用以后，可以简写为：\n\n```java\nString type = \"STR\";\nPredicate<String> predicate = type::equals;\nSystem.out.println(predicate.test(\"STR\"));\n```\n\n### 构造方法\n指向**构造方法**的引用，语法：`类名::new`，类名放在**分隔符**`::`前，new放在**分隔符**`::`后。例如：\n\n```java\n(String brand, String type) -> new Equipment(brand, type)\n```\n\n使用方法引用以后，可以简写为：\n\n```java\nEquipment::new\n```\n\n# 应用\n## 背景\n在一个数据库表中，存在**一对多**的E-R关系，对父表新增一条数据时，子表的若干条数据需要关联父表的这行数据；进一步地，需要在对父表删除一行数据时，与其关联的若干条要被**同步删除**，以保证数据之间的约束。\n\n## 思路\n首先分析父表与子表的关联关系，找出子表是与父表的哪一个字段关联的，这样即可根据父表的字段找到子表的数据，随后即可删除子表的数据。在编写业务逻辑时需注意：先删除子表数据，后删除父表数据。\n\n## 应用场景\n使用其他业务方法得到一个由子表数据组成的实体数组时，需要根据每个实体的`id`进行删除。传统的写法是使用`for`循环遍历这个数组，在循环体中写一行sql语句删除逐行数据，这种写法需要创建多个临时变量储存临时数据，较为繁琐，也显得代码块较为臃肿。利用Java函数式编程的新特性即可简化代码。\n\n## 解决方案\n创建`Stream`储存该实体数组进行流式处理，代替`for`循环，使用`map`将数组中的每个实体转换为实体对应的`id`。`map`方法又可接收`Function`接口对象的方法引用，无需创建实例即可引用方法，进一步减少了代码量。\n\n## 实例\n假设已得到一个实体数组：\n```java\nList<EmissionCalcParamDTO> emissionCalcParams\n```\n\n现调用一个入参为数组的`deleteBatchIds()`方法，它是MyBatis-Plus提供的接口，用于删除多行数据。调用前需先判断数组是否为空，写法如下：\n\n```java\nif (CollectionUtils.isNotEmpty(emissionCalcParams)) {\n    emissionSourceCalcParamMapper.deleteBatchIds(emissionCalcParams.stream()\n        .map(EmissionCalcParamDTO::getId)\n        .collect(Collectors.toList()));\n}\n```\n\n上面的代码在把实体转换为`id`后又将其组合成数组，作为`deleteBatchIds()`的入参，可以说用一行代码解决了传统写法十几行的工作量。\n> 注意，上述编码过程中还使用到了`Stream`流和`map`方法，并使用`MyBatis-Plus`简化数据库操作，上述代码基于`Spring Boot`框架进行编写。对于上述使用到的技术，我将在后面的文章中详细介绍。\n\n---\n**非常感谢你的阅读，辛苦了！**\n\n---\n参考文章： (感谢以下资料提供的帮助)\n- [函数式编程 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1252599548343744/1255943847278976)\n","tags":["后端","Java","Lambda"],"categories":["学习笔记"]},{"title":"helloworld","url":"/posts/bce9a85f8d8c.html","content":"# 你好！\n这是我的第一篇博客。\n# Hello!\nThis is my first blog.","categories":["杂谈"]}]